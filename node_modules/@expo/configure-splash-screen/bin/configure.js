#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = __importDefault(require("commander"));
const color_string_1 = __importDefault(require("color-string"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const android_1 = __importDefault(require("./android"));
const constants_1 = require("./constants");
const ios_1 = __importDefault(require("./ios"));
async function action(configuration) {
    const { platform, ...restParams } = configuration;
    const rootDir = path_1.default.resolve();
    switch (platform) {
        case constants_1.Platform.ANDROID:
            await android_1.default(rootDir, restParams);
            break;
        case constants_1.Platform.IOS:
            await ios_1.default(rootDir, restParams);
            break;
        case constants_1.Platform.ALL:
        default:
            await android_1.default(rootDir, restParams);
            await ios_1.default(rootDir, restParams);
            break;
    }
}
function getAvailableOptions(o) {
    return Object.values(o).join(' | ');
}
function logErrorAndExit(errorMessage) {
    console.error(errorMessage);
    process.exit(1);
}
/**
 * Ensures following semantic requirements are met:
 * @param configuration.imagePath path that points to a valid .png file
 * @param configuration.resizeMode ResizeMode.NATIVE is selected only with Platform.ANDROID
 * @param configuration.backgroundColor is valid hex #RGB/#RGBA color
 */
async function validateConfiguration(configuration) {
    const { resizeMode, imagePath: imagePathString, platform } = configuration;
    // check for `native` resizeMode being selected only for `android` platform
    if (resizeMode === constants_1.ResizeMode.NATIVE && platform !== constants_1.Platform.ANDROID) {
        logErrorAndExit(`error: Invalid resizeMode '${resizeMode}' for platform '${platform}'.`);
    }
    const backgroundColor = color_string_1.default.get(configuration.backgroundColor);
    if (!backgroundColor) {
        logErrorAndExit(`error: Invalid value '${configuration.backgroundColor}' for argument 'backgroundColor'.`);
    }
    if (imagePathString) {
        const imagePath = path_1.default.resolve(imagePathString);
        // check if `imagePath` exists
        if (!(await fs_extra_1.default.pathExists(imagePath))) {
            logErrorAndExit(`error: Invalid path '${imagePathString}' for argument 'imagePath'. File does not exist. Provide path to a valid .png file.`);
        }
        // check if `imagePath` is a readable .png file
        if (path_1.default.extname(imagePath) !== '.png') {
            logErrorAndExit(`error: Invalid path '${imagePathString}' for argument 'imagePath'. File is not a .png file. Provide path to a valid .png file.`);
        }
    }
    return {
        ...configuration,
        backgroundColor,
    };
}
function validateResizeMode(userInput) {
    if (!Object.values(constants_1.ResizeMode).includes(userInput)) {
        logErrorAndExit(`error: Unknown value '${userInput}' for option 'resizeMode'.`);
    }
    return userInput;
}
function validatePlatform(userInput) {
    if (!Object.values(constants_1.Platform).includes(userInput)) {
        logErrorAndExit(`error: Unknown value '${userInput}' for option 'platform'.`);
    }
    return userInput;
}
commander_1.default
    .arguments('<backgroundColor> [imagePath]')
    .description('Idempotent operation that configures native splash screens using passed .png file that would be used in native splash screen.', {
    backgroundColor: `Valid css-formatted color (hex (#RRGGBB[AA]), rgb[a], hsl[a], named color (https://drafts.csswg.org/css-color/#named-colors)) that would be used as background color for native splash screen view.`,
    imagePath: `Path to a valid .png image.`,
})
    .allowUnknownOption(false)
    .option('-r, --resize-mode [resizeMode]', `ResizeMode to be used for native splash screen image. Available values: ${getAvailableOptions(constants_1.ResizeMode)} (only available for android platform)).`, validateResizeMode, constants_1.ResizeMode.CONTAIN)
    .option('-p, --platform [platform]', `Selected platform to configure. Available values: ${getAvailableOptions(constants_1.Platform)}.`, validatePlatform, constants_1.Platform.ALL)
    .action(async (backgroundColor, imagePath, { resizeMode, platform }) => {
    const configuration = { imagePath, backgroundColor, resizeMode, platform };
    const validatedConfiguration = await validateConfiguration(configuration);
    return action(validatedConfiguration);
});
commander_1.default.parse(process.argv);
//# sourceMappingURL=configure.js.map